{% extends "layout.html" %}

{% block title %}Dashboard - Logs em Tempo Real{% endblock %}

{% block content %}
<div class="main-header">
    <h2>Logs em Tempo Real: <span id="log-title">nftables</span>.log</h2>
    <div class="controls">
        <label for="log-selector">Selecionar Log:</label>
        <select id="log-selector">
            {% for log in allowed_logs %}
            <option value="{{ log }}" {% if log == 'nftables' %}selected{% endif %}>{{ log }}</option>
            {% endfor %}
        </select>
    </div>
</div>

<pre id="log-container">Carregando logs...</pre>

<div class="footer-status">
    <svg id="pause-icon" class="status-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--orange)">
        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
    </svg>
    <span id="status-text">Iniciando...</span>
</div>

<script>
    const logContainer = document.getElementById('log-container');
    const statusText = document.getElementById('status-text');
    const logTitleElement = document.getElementById('log-title');
    const logSelector = document.getElementById('log-selector');
    const pauseIcon = document.getElementById('pause-icon');
    
    let currentLogName = logSelector.value;
    let fetchIntervalId = null;
    let inactivityTimerId = null;
    let countdownIntervalId = null;
    let isPausedByUser = false;

    function startLogFetching() {
        if (fetchIntervalId) clearInterval(fetchIntervalId);
        fetchLogs();
        fetchIntervalId = setInterval(() => {
            if (!isPausedByUser) fetchLogs();
        }, 5000);
    }

    function pauseAutoScroll() {
        if (!isPausedByUser) {
            isPausedByUser = true;
            updateStatus('paused');
        }
        clearTimeout(inactivityTimerId);
        inactivityTimerId = setTimeout(resumeAutoScroll, 15000);
    }

    function resumeAutoScroll() {
        clearTimeout(inactivityTimerId);
        clearInterval(countdownIntervalId);
        if (isPausedByUser) {
            isPausedByUser = false;
            updateStatus('resumed');
            fetchLogs();
        }
    }

    async function fetchLogs() {
        const shouldScrollToBottom = logContainer.scrollTop + logContainer.clientHeight >= logContainer.scrollHeight - 20;
        try {
            const response = await fetch(`/api/logs/${currentLogName}`);
            if (!response.ok) {
                if (response.status === 401) window.location.reload();
                const errorData = await response.json();
                throw new Error(errorData.details || `Erro ${response.status}`);
            }
            const data = await response.json();
            const coloredContent = data.content.split('\n').map(colorizeLogLine).join('\n');
            logContainer.innerHTML = coloredContent;
            logTitleElement.textContent = data.log_name;
            if (shouldScrollToBottom && !isPausedByUser) {
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            if (!isPausedByUser) updateStatus('running');
        } catch (error) {
            logContainer.textContent = `Falha ao carregar logs.\nDetalhes: ${error.message}`;
            updateStatus('error');
        }
    }

    function updateStatus(state) {
        statusText.classList.remove('blinking');
        pauseIcon.style.display = 'none';
        clearInterval(countdownIntervalId);

        switch (state) {
            case 'paused':
                let countdown = 15;
                statusText.innerHTML = `Pausado. Retornando em <span class="countdown-timer">${countdown}s</span>...`;
                statusText.classList.add('blinking');
                pauseIcon.style.display = 'inline-block';
                countdownIntervalId = setInterval(() => {
                    countdown--;
                    const countdownElement = statusText.querySelector('.countdown-timer');
                    if (countdownElement) countdownElement.textContent = `${countdown}s`;
                    if (countdown <= 0) clearInterval(countdownIntervalId);
                }, 1000);
                break;
            case 'resumed':
                statusText.textContent = `Atualização automática reativada.`;
                break;
            case 'running':
                statusText.textContent = `OK - Atualizado em ${new Date().toLocaleTimeString()}`;
                break;
            case 'error':
                statusText.textContent = 'Erro ao buscar logs.';
                break;
        }
    }

    logContainer.addEventListener('scroll', () => {
        const atBottom = logContainer.scrollTop + logContainer.clientHeight >= logContainer.scrollHeight - 20;
        if (atBottom) {
            resumeAutoScroll();
        } else {
            pauseAutoScroll();
        }
    });

    logSelector.addEventListener('change', (event) => {
        currentLogName = event.target.value;
        logContainer.textContent = `Carregando logs de ${currentLogName}...`;
        resumeAutoScroll();
        startLogFetching();
    });

    function colorizeLogLine(line) {
        let safeLine = line.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const rules = [
            { regex: /(OUTPUT_DROP|INPUT_DROP|FORWARD_DROP|REJECT)/g, class: 'highlight-drop' },
            { regex: /(ACCEPT|ALLOW)/g, class: 'highlight-accept' },
            { regex: /(SRC=)([\d\.]+)/g, replacement: `<span class="highlight-key">$1</span><span class="highlight-src">$2</span>` },
            { regex: /(DST=)([\d\.]+)/g, replacement: `<span class="highlight-key">$1</span><span class="highlight-dst">$2</span>` },
            { regex: /(PROTO=)(\w+)/g, replacement: `<span class="highlight-key">$1</span><span class="highlight-proto">$2</span>` },
            { regex: /(IN=|OUT=|SPT=|DPT=|LEN=|TOS=|TTL=|ID=)/g, class: 'highlight-key' }
        ];
        rules.forEach(rule => {
            if (rule.replacement) {
                safeLine = safeLine.replace(rule.regex, rule.replacement);
            } else {
                safeLine = safeLine.replace(rule.regex, `<span class="${rule.class}">$1</span>`);
            }
        });
        return safeLine;
    }

    startLogFetching();
</script>
{% endblock %}